import threading
import time
from abc import ABC, abstractmethod

from typing_extensions import List, Type, Optional

from pycram.datastructures.dataclasses import ContactPointsList
from pycram.datastructures.enums import ObjectType
from pycram.datastructures.world import World
from pycram.world_concepts.world_object import Object

from .event_detectors import ContactDetector, LossOfContactDetector, EventDetector
from .events import ContactEvent, Event, AgentContactEvent, PickUpEvent
from .event_logger import EventLogger


class EpisodePlayer(threading.Thread, ABC):
    def __init__(self):
        super().__init__()
        self._ready = False

    @property
    def ready(self):
        return self._ready

    @abstractmethod
    def run(self):
        """
        The run method that is called when the thread is started. This should start the episode player thread.
        """
        pass


class EpisodeSegmenter(ABC):

    def __init__(self, episode_player: EpisodePlayer, detectors_to_start: List[Type[EventDetector]],
                 annotate_events: bool = False):
        """
        Initializes the EpisodeSegmenter class.

        :param episode_player: The thread that plays the episode and generates the motion.
        """
        self.episode_player: EpisodePlayer = episode_player
        self.detectors_to_start: List[Type[EventDetector]] = detectors_to_start
        self.logger = EventLogger(annotate_events, [PickUpEvent])
        self.avoid_objects = ['particle', 'floor', 'kitchen']  # TODO: Make it a function, to be more general
        self.tracked_objects = []
        self.detector_threads = {}
        self.pick_up_detectors = {}

    def start_motion_generator_thread_and_wait_till_ready(self) -> None:
        """
        Start the File player thread, and waits until the File player thread is
        ready (e.g., the replay environment is initialized with all objects in starting poses).
        """
        self.episode_player.start()
        while not self.episode_player.ready:
            time.sleep(0.1)

    def run_event_detectors(self) -> None:
        """
        Run the event detectors on the motion generated by the motion generator thread.
        """
        self.run_initial_event_detectors()

        while self.episode_player.is_alive() or self.logger.event_queue.unfinished_tasks > 0:

            thread_id, next_event = self.logger.get_next_event()

            if next_event is None:
                time.sleep(0.01)
                continue

            self.process_event(next_event)

        self.join()
        self.logger.print_events()

    @abstractmethod
    def process_event(self, event: Event) -> None:
        """
        Process the event generated by the event logger.
        """
        pass

    @abstractmethod
    def run_initial_event_detectors(self) -> None:
        """
        Run the initial event detectors on the motion generated by the motion generator thread.
        """
        pass

    def update_tracked_contacts(self, event: ContactEvent) -> None:
        """
        Update tracked contacts on trigger of a contact event by starting the contact threads for the object and the
         pickup thread for the object.

        :param event: The ContactEvent instance that represents the contact event.
        """
        objects_in_contact = event.contact_points.get_objects_that_have_points()
        for obj_in_contact in objects_in_contact:
            if any([k in obj_in_contact.name.lower() for k in self.avoid_objects]):
                continue

            if obj_in_contact not in self.tracked_objects:
                print(f"Creating contact threads for object {obj_in_contact.name}")
                self.start_contact_threads_for_obj_and_update_tracked_objs(obj_in_contact, event)

            for event_detector in self.detectors_to_start:
                if event_detector.start_condition_checker(event):
                    filtered_event = event_detector.filter_event(event)
                    self.start_detector_thread_for_starter_event(filtered_event, event_detector)

    def start_contact_threads_for_obj_and_update_tracked_objs(self, obj: Object,
                                                              event: Optional[ContactEvent] = None) -> None:
        """
        Start the contact threads for the object and updates the tracked objects.

        :param obj: The Object instance for which the contact threads are started.
        :param event: The ContactEvent instance that represents the contact event with the object.
        """
        if event is None:
            if obj.obj_type in [ObjectType.HUMAN, ObjectType.ROBOT]:
                event = AgentContactEvent(ContactPointsList([]), obj)
            else:
                event = ContactEvent(ContactPointsList([]), obj)
        for detector in (ContactDetector, LossOfContactDetector):
            detector_thread = detector(self.logger, obj)
            detector_thread.start()
            self.detector_threads[(event, detector)] = detector_thread
        self.tracked_objects.append(obj)

    def start_detector_thread_for_starter_event(self, starter_event: Event,
                                                detector_type: Type[EventDetector]):
        """
        Start the detector thread for the given starter event.

        :param starter_event: The event that starts the detector thread.
        :param detector_type: The type of the detector.
        """
        if (starter_event, detector_type) in self.detector_threads.keys():
            detector = self.detector_threads[(starter_event, detector_type)]
            if detector.is_alive() or (detector.detected_before and detector.run_once):
                return
        detector = detector_type(self.logger, starter_event)
        detector.start()
        self.detector_threads[(starter_event, detector_type)] = detector
        print(f"Created {detector_type.__name__} for starter event {starter_event}")

    def join(self):
        """
        Join all the threads.
        """
        self.episode_player.join()

        for detector_thread in self.detector_threads.values():
            detector_thread.exit_thread = True
            detector_thread.join()

        self.logger.join()


class AgentBasedEpisodeSegmenter(EpisodeSegmenter):
    """
    The AgentBasedEpisodeSegmenter class is used to segment motions into activities (e.g. PickUp) by tracking the
     events that are relevant to the agent for example contact events of the hands or robot.
    """

    def process_event(self, event: Event) -> None:
        if isinstance(event, ContactEvent):
            self.update_tracked_contacts(event)

    def run_initial_event_detectors(self) -> None:
        self.track_agent_contacts()

    def track_agent_contacts(self) -> None:
        """
        Start the contact threads for the agents.
        """
        agents = self.get_agents()
        for agent in agents:
            self.start_contact_threads_for_obj_and_update_tracked_objs(agent)

    @staticmethod
    def get_agents() -> List[Object]:
        """
        Get the hands from the world.

        :return: A list of Object instances that represent the hands.
        """
        return [obj for obj in World.current_world.objects if obj.obj_type in [ObjectType.HUMAN, ObjectType.ROBOT]]
