#!/usr/bin/env python3
"""Combines autogenerated pydantic models to single file to eliminate circular imports.

Also:
- updates the base class for String rootes to StrRootModel to coerce non-string types to string.

usage: _modify_model.py <model_file_dir>
"""

import argparse
import ast
from pathlib import Path

STRAY_MODEL_FILES = ["number_property.py"]
TARGET_MODEL_FILE = "__init__.py"


def _read_classes_from_file(modelfile_path: str) -> str:
    """Gathers all classes defined in a python file and returns as a string w/out imports.

    Returns:
        str: The string representation of all classes defined in the file, including their
            text documentation and code.
    """
    with open(modelfile_path, "r") as source:
        lines = source.readlines()

    class_lines = []
    in_class = False

    for line in lines:
        if line.startswith("class"):
            in_class = True
        if in_class:
            class_lines.append(line)
        if line.strip().count(" ") == 0:
            in_class = False

    code = "".join(class_lines)

    return code


def _get_class_names_from_txt(txt: str) -> list:
    """Returns a list of class names from a string python code.

    Args:
        txt: str - the string of classes to parse
    """
    class_names = []
    lines = txt.split("\n")

    for line in lines:
        if line.startswith("class"):
            class_name = line.split(" ")[1].split("(")[0]
            class_names.append(class_name)

    return class_names


def _merge_classes_from_one_file_to_another(
    source_class_filepath: str, target_model_file_txt: str
) -> str:
    source_classes_txt = _read_classes_from_file(source_class_filepath)
    source_classes_names = _get_class_names_from_txt(source_classes_txt)
    # print(f"Found class names: {source_classes_names}")

    # makes sure there aren't any reference collisions
    existing_class_names = _get_class_names_from_txt(target_model_file_txt)
    if any([class_name in existing_class_names for class_name in source_classes_names]):
        raise ValueError(
            f"Class name collision between {target_model_path} and {source_class_filepath}."
        )

    # update references to be local
    source_class_basename = Path(stray_model_path).stem
    target_model_file_txt = target_model_file_txt.replace(
        f"from . import {source_class_basename}", ""
    )
    for _c in source_classes_names:
        target_model_file_txt = target_model_file_txt.replace(
            f"{source_class_basename}.{_c}", f"{_c}"
        )

    # Insert stray_classes_to_import_txt between import statements and other classes
    _first_class_name = _get_class_names_from_txt(target_model_file_txt)[0]
    _class_defs_begin = target_model_file_txt.find(_first_class_name) - len("class ")

    target_model_file_txt = (
        target_model_file_txt[:_class_defs_begin]
        + "\n\n"
        + source_classes_txt
        + target_model_file_txt[_class_defs_begin:]
    )

    # makes sure that the classes were successfully imported
    _all_class_names = _get_class_names_from_txt(target_model_file_txt)
    _missing_class_names = set(source_classes_names) - set(_all_class_names)
    if _missing_class_names:
        raise ValueError(f"Failed to import classes: {_missing_class_names}")

    return target_model_file_txt


_config_wo_protected_namespaces = ast.ClassDef(
    name="ConfigDict",
    bases=[],
    keywords=[],
    body=[
        ast.Assign(
            targets=[ast.Name(id="protected_namespaces", ctx=ast.Store())],
            value=ast.Tuple(elts=[], ctx=ast.Load()),
        )
    ],
    decorator_list=[],
)


def _is_class_with_var(node, var_name="model_"):
    if not isinstance(node, ast.ClassDef):
        return False
    has_var = any(
        child
        for child in getattr(node, "body", [])  # Use getattr to handle ImportFrom
        if isinstance(child, ast.Assign)
        and any(target.id.startswith(var_name) for target in child.targets)
    )
    return has_var


def _get_class(node, class_name="ConfigDict") -> ast.ClassDef:
    for child in node.body:
        if isinstance(child, ast.ClassDef) and child.name == class_name:
            return child
    return None


def _replace_base_class(class_file_txt: str) -> str:
    """Replaces the base class of the model with a new base class that validates int to str.

    Adds import statement for new base class.
    """
    class_file_txt = class_file_txt.replace(
        "root: Annotated[str,", "root: Annotated[str,BeforeValidator(str),"
    )
    class_file_txt = class_file_txt.replace(", RootModel", ", RootModel, BeforeValidator", 1)
    return class_file_txt


def _remove_protected_namespaces(class_file_txt: str) -> str:
    tree = ast.parse(class_file_txt)
    # Traverse the AST
    for node in ast.walk(tree):
        if _is_class_with_var(node, var_name="model_"):
            _config_dict = _get_class(node, class_name="ConfigDict")
            if _config_dict is None:
                node.body.append(_config_wo_protected_namespaces)
            else:
                # Add protected_namespaces = () to the existing ConfigDict class
                protected_namespaces = ast.Assign(
                    targets=[ast.Name(id="protected_namespaces", ctx=ast.Store())],
                    value=ast.Tuple(elts=[], ctx=ast.Load()),
                )
                _config_dict.body.append(protected_namespaces)

    # Add line numbers to Assign nodes
    for node in ast.walk(tree):
        if isinstance(node, ast.Assign):
            node.lineno = 1
            node.col_offset = 0

    return ast.unparse(tree)


if __name__ == "__main__":
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Process some integers.")
    parser.add_argument("dir", help="The directory where the model files are located")
    parser.add_argument(
        "--pydantic-v1", action="store_true", help="Flag to indicate Pydantic version 1"
    )

    args = parser.parse_args()

    # Update file paths based on command-line argument
    stray_model_paths = [Path(args.dir) / filename for filename in STRAY_MODEL_FILES]
    stray_model_paths = [p for p in stray_model_paths if p.exists]
    # print(f"MERGING MODEL FILES: {stray_model_paths}")
    target_model_path = Path(args.dir) / TARGET_MODEL_FILE

    with open(target_model_path, "r") as target_model_file:
        target_model_file_txt = target_model_file.read()

    existing_class_names = _get_class_names_from_txt(target_model_file_txt)

    for stray_model_path in stray_model_paths:
        target_model_file_txt = _merge_classes_from_one_file_to_another(
            stray_model_path, target_model_file_txt
        )

    target_model_file_txt = _replace_base_class(target_model_file_txt)

    if not args.pydantic_v1:
        target_model_file_txt = _remove_protected_namespaces(target_model_file_txt)

    # overwrite the target model file with the new text
    with open(target_model_path, "w") as target_model_file:
        target_model_file.write(target_model_file_txt)

    # remove the stray model files that aren't necessary anymore
    for stray_model_path in stray_model_paths:
        stray_model_path.unlink()
