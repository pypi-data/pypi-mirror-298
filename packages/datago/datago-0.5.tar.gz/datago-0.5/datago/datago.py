
# python wrapper for package datago/pkg/client within overall package datago
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -author=Photoroom -email=team@photoroom.com -url= -name=datago -version=0.3 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _datago
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from datago import datago
# and then refer to everything using datago. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []datago.SampleMetadata
class Slice_datago_SampleMetadata(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Slice_datago_SampleMetadata_CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_datago_SampleMetadata.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Slice_datago_SampleMetadata len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'datago.Slice_datago_SampleMetadata([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _datago.Slice_datago_SampleMetadata_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _datago.Slice_datago_SampleMetadata_len(self.handle)
				return Slice_datago_SampleMetadata(handle=_datago.Slice_datago_SampleMetadata_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SampleMetadata(handle=_datago.Slice_datago_SampleMetadata_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_datago.Slice_datago_SampleMetadata_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_datago_SampleMetadata.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SampleMetadata(handle=_datago.Slice_datago_SampleMetadata_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_datago.Slice_datago_SampleMetadata_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []datago.URLLatent
class Slice_datago_URLLatent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Slice_datago_URLLatent_CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_datago_URLLatent.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Slice_datago_URLLatent len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'datago.Slice_datago_URLLatent([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _datago.Slice_datago_URLLatent_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _datago.Slice_datago_URLLatent_len(self.handle)
				return Slice_datago_URLLatent(handle=_datago.Slice_datago_URLLatent_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return URLLatent(handle=_datago.Slice_datago_URLLatent_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_datago.Slice_datago_URLLatent_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_datago_URLLatent.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = URLLatent(handle=_datago.Slice_datago_URLLatent_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_datago.Slice_datago_URLLatent_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]datago.ImagePayload
class Map_string_datago_ImagePayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Map_string_datago_ImagePayload_CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_datago_ImagePayload.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_datago.Map_string_datago_ImagePayload_set(self.handle, k, v)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Map_string_datago_ImagePayload len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'datago.Map_string_datago_ImagePayload({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _datago.Map_string_datago_ImagePayload_len(self.handle)
	def __getitem__(self, key):
		return ImagePayload(handle=_datago.Map_string_datago_ImagePayload_elem(self.handle, key))
	def __setitem__(self, key, value):
		_datago.Map_string_datago_ImagePayload_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _datago.Map_string_datago_ImagePayload_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_datago.Map_string_datago_ImagePayload_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _datago.Map_string_datago_ImagePayload_contains(self.handle, key)

# Python type for map map[string]datago.LatentPayload
class Map_string_datago_LatentPayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Map_string_datago_LatentPayload_CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_datago_LatentPayload.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_datago.Map_string_datago_LatentPayload_set(self.handle, k, v)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Map_string_datago_LatentPayload len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'datago.Map_string_datago_LatentPayload({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _datago.Map_string_datago_LatentPayload_len(self.handle)
	def __getitem__(self, key):
		return LatentPayload(handle=_datago.Map_string_datago_LatentPayload_elem(self.handle, key))
	def __setitem__(self, key, value):
		_datago.Map_string_datago_LatentPayload_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _datago.Map_string_datago_LatentPayload_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_datago.Map_string_datago_LatentPayload_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _datago.Map_string_datago_LatentPayload_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Map_string_interface__CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_datago.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'datago.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _datago.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _datago.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_datago.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _datago.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_datago.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _datago.Map_string_interface__contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct datago.ImageSize
class ImageSize(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ImageSize_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Width = args[0]
			if "Width" in kwargs:
				self.Width = kwargs["Width"]
			if  1 < len(args):
				self.Height = args[1]
			if "Height" in kwargs:
				self.Height = kwargs["Height"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImageSize{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImageSize ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Width(self):
		"""Making it explicit how we store width and height, guarding against potential confusion
		"""
		return _datago.datago_ImageSize_Width_Get(self.handle)
	@Width.setter
	def Width(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageSize_Width_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageSize_Width_Set(self.handle, value)
	@property
	def Height(self):
		return _datago.datago_ImageSize_Height_Get(self.handle)
	@Height.setter
	def Height(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageSize_Height_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageSize_Height_Set(self.handle, value)
	def AspectRatio(self):
		"""AspectRatio() float"""
		return _datago.datago_ImageSize_AspectRatio(self.handle)

# Python type for struct datago.Sample
class Sample(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_Sample_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Source = args[1]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  2 < len(args):
				self.Attributes = args[2]
			if "Attributes" in kwargs:
				self.Attributes = kwargs["Attributes"]
			if  3 < len(args):
				self.Image = args[3]
			if "Image" in kwargs:
				self.Image = kwargs["Image"]
			if  4 < len(args):
				self.Masks = args[4]
			if "Masks" in kwargs:
				self.Masks = kwargs["Masks"]
			if  5 < len(args):
				self.AdditionalImages = args[5]
			if "AdditionalImages" in kwargs:
				self.AdditionalImages = kwargs["AdditionalImages"]
			if  6 < len(args):
				self.Latents = args[6]
			if "Latents" in kwargs:
				self.Latents = kwargs["Latents"]
			if  7 < len(args):
				self.CocaEmbedding = args[7]
			if "CocaEmbedding" in kwargs:
				self.CocaEmbedding = kwargs["CocaEmbedding"]
			if  8 < len(args):
				self.Tags = args[8]
			if "Tags" in kwargs:
				self.Tags = kwargs["Tags"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Sample{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Sample ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _datago.datago_Sample_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_ID_Set(self.handle, value.handle)
		else:
			_datago.datago_Sample_ID_Set(self.handle, value)
	@property
	def Source(self):
		return _datago.datago_Sample_Source_Get(self.handle)
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Source_Set(self.handle, value.handle)
		else:
			_datago.datago_Sample_Source_Set(self.handle, value)
	@property
	def Attributes(self):
		return Map_string_interface_(handle=_datago.datago_Sample_Attributes_Get(self.handle))
	@Attributes.setter
	def Attributes(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Attributes_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Image(self):
		return ImagePayload(handle=_datago.datago_Sample_Image_Get(self.handle))
	@Image.setter
	def Image(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Image_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Masks(self):
		return Map_string_datago_ImagePayload(handle=_datago.datago_Sample_Masks_Get(self.handle))
	@Masks.setter
	def Masks(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Masks_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AdditionalImages(self):
		return Map_string_datago_ImagePayload(handle=_datago.datago_Sample_AdditionalImages_Get(self.handle))
	@AdditionalImages.setter
	def AdditionalImages(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_AdditionalImages_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Latents(self):
		return Map_string_datago_LatentPayload(handle=_datago.datago_Sample_Latents_Get(self.handle))
	@Latents.setter
	def Latents(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Latents_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CocaEmbedding(self):
		return go.Slice_float32(handle=_datago.datago_Sample_CocaEmbedding_Get(self.handle))
	@CocaEmbedding.setter
	def CocaEmbedding(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_CocaEmbedding_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Tags(self):
		return go.Slice_string(handle=_datago.datago_Sample_Tags_Get(self.handle))
	@Tags.setter
	def Tags(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Tags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct datago.SampleMetadata
class SampleMetadata(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_SampleMetadata_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Id = args[0]
			if "Id" in kwargs:
				self.Id = kwargs["Id"]
			if  1 < len(args):
				self.Attributes = args[1]
			if "Attributes" in kwargs:
				self.Attributes = kwargs["Attributes"]
			if  2 < len(args):
				self.ImageDirectURL = args[2]
			if "ImageDirectURL" in kwargs:
				self.ImageDirectURL = kwargs["ImageDirectURL"]
			if  3 < len(args):
				self.Latents = args[3]
			if "Latents" in kwargs:
				self.Latents = kwargs["Latents"]
			if  4 < len(args):
				self.Tags = args[4]
			if "Tags" in kwargs:
				self.Tags = kwargs["Tags"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.SampleMetadata{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.SampleMetadata ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Id(self):
		return _datago.datago_SampleMetadata_Id_Get(self.handle)
	@Id.setter
	def Id(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SampleMetadata_Id_Set(self.handle, value.handle)
		else:
			_datago.datago_SampleMetadata_Id_Set(self.handle, value)
	@property
	def Attributes(self):
		return Map_string_interface_(handle=_datago.datago_SampleMetadata_Attributes_Get(self.handle))
	@Attributes.setter
	def Attributes(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SampleMetadata_Attributes_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ImageDirectURL(self):
		return _datago.datago_SampleMetadata_ImageDirectURL_Get(self.handle)
	@ImageDirectURL.setter
	def ImageDirectURL(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SampleMetadata_ImageDirectURL_Set(self.handle, value.handle)
		else:
			_datago.datago_SampleMetadata_ImageDirectURL_Set(self.handle, value)
	@property
	def Latents(self):
		return Slice_datago_URLLatent(handle=_datago.datago_SampleMetadata_Latents_Get(self.handle))
	@Latents.setter
	def Latents(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SampleMetadata_Latents_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Tags(self):
		return go.Slice_string(handle=_datago.datago_SampleMetadata_Tags_Get(self.handle))
	@Tags.setter
	def Tags(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SampleMetadata_Tags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct datago.URLLatent
class URLLatent(go.GoClass):
	"""--- DB Communication structures ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_URLLatent_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.URL = args[0]
			if "URL" in kwargs:
				self.URL = kwargs["URL"]
			if  1 < len(args):
				self.LatentType = args[1]
			if "LatentType" in kwargs:
				self.LatentType = kwargs["LatentType"]
			if  2 < len(args):
				self.IsMask = args[2]
			if "IsMask" in kwargs:
				self.IsMask = kwargs["IsMask"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.URLLatent{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.URLLatent ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def URL(self):
		return _datago.datago_URLLatent_URL_Get(self.handle)
	@URL.setter
	def URL(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_URLLatent_URL_Set(self.handle, value.handle)
		else:
			_datago.datago_URLLatent_URL_Set(self.handle, value)
	@property
	def LatentType(self):
		return _datago.datago_URLLatent_LatentType_Get(self.handle)
	@LatentType.setter
	def LatentType(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_URLLatent_LatentType_Set(self.handle, value.handle)
		else:
			_datago.datago_URLLatent_LatentType_Set(self.handle, value)
	@property
	def IsMask(self):
		return _datago.datago_URLLatent_IsMask_Get(self.handle)
	@IsMask.setter
	def IsMask(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_URLLatent_IsMask_Set(self.handle, value.handle)
		else:
			_datago.datago_URLLatent_IsMask_Set(self.handle, value)

# Python type for struct datago.DataroomClient
class DataroomClient(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_DataroomClient_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DataroomClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DataroomClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Start(self, goRun=False):
		"""Start() 
		
		Start the background downloads, make it ready to serve samples. Will grow the memory and CPU footprint
		"""
		_datago.datago_DataroomClient_Start(self.handle, goRun)
	def GetSample(self):
		"""GetSample() object
		
		Get a deserialized sample from the client
		"""
		return Sample(handle=_datago.datago_DataroomClient_GetSample(self.handle))
	def Stop(self, goRun=False):
		"""Stop() 
		
		Stop the background downloads, will clear the memory and CPU footprint
		"""
		_datago.datago_DataroomClient_Stop(self.handle, goRun)

# Python type for struct datago.ImagePayload
class ImagePayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ImagePayload_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Data = args[0]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  1 < len(args):
				self.OriginalHeight = args[1]
			if "OriginalHeight" in kwargs:
				self.OriginalHeight = kwargs["OriginalHeight"]
			if  2 < len(args):
				self.OriginalWidth = args[2]
			if "OriginalWidth" in kwargs:
				self.OriginalWidth = kwargs["OriginalWidth"]
			if  3 < len(args):
				self.Height = args[3]
			if "Height" in kwargs:
				self.Height = kwargs["Height"]
			if  4 < len(args):
				self.Width = args[4]
			if "Width" in kwargs:
				self.Width = kwargs["Width"]
			if  5 < len(args):
				self.Channels = args[5]
			if "Channels" in kwargs:
				self.Channels = kwargs["Channels"]
			if  6 < len(args):
				self.DataPtr = args[6]
			if "DataPtr" in kwargs:
				self.DataPtr = kwargs["DataPtr"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImagePayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImagePayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Data(self):
		return go.Slice_uint8(handle=_datago.datago_ImagePayload_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def OriginalHeight(self):
		return _datago.datago_ImagePayload_OriginalHeight_Get(self.handle)
	@OriginalHeight.setter
	def OriginalHeight(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_OriginalHeight_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_OriginalHeight_Set(self.handle, value)
	@property
	def OriginalWidth(self):
		return _datago.datago_ImagePayload_OriginalWidth_Get(self.handle)
	@OriginalWidth.setter
	def OriginalWidth(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_OriginalWidth_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_OriginalWidth_Set(self.handle, value)
	@property
	def Height(self):
		return _datago.datago_ImagePayload_Height_Get(self.handle)
	@Height.setter
	def Height(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Height_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_Height_Set(self.handle, value)
	@property
	def Width(self):
		return _datago.datago_ImagePayload_Width_Get(self.handle)
	@Width.setter
	def Width(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Width_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_Width_Set(self.handle, value)
	@property
	def Channels(self):
		return _datago.datago_ImagePayload_Channels_Get(self.handle)
	@Channels.setter
	def Channels(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Channels_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_Channels_Set(self.handle, value)
	@property
	def DataPtr(self):
		return _datago.datago_ImagePayload_DataPtr_Get(self.handle)
	@DataPtr.setter
	def DataPtr(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_DataPtr_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_DataPtr_Set(self.handle, value)

# Python type for struct datago.PageRequest
class PageRequest(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_PageRequest_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.PageRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.PageRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct datago.Response
class Response(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_Response_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Next = args[0]
			if "Next" in kwargs:
				self.Next = kwargs["Next"]
			if  1 < len(args):
				self.SampleMetadata = args[1]
			if "SampleMetadata" in kwargs:
				self.SampleMetadata = kwargs["SampleMetadata"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Response{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Response ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Next(self):
		return _datago.datago_Response_Next_Get(self.handle)
	@Next.setter
	def Next(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Response_Next_Set(self.handle, value.handle)
		else:
			_datago.datago_Response_Next_Set(self.handle, value)
	@property
	def SampleMetadata(self):
		return Slice_datago_SampleMetadata(handle=_datago.datago_Response_SampleMetadata_Get(self.handle))
	@SampleMetadata.setter
	def SampleMetadata(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Response_SampleMetadata_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct datago.URLPayload
class URLPayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_URLPayload_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.URLPayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.URLPayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct datago.ARAwareTransform
class ARAwareTransform(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ARAwareTransform_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ARAwareTransform{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ARAwareTransform ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct datago.LatentPayload
class LatentPayload(go.GoClass):
	"""--- Sample data structures - these will be exposed to the Python world ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_LatentPayload_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Data = args[0]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  1 < len(args):
				self.Len = args[1]
			if "Len" in kwargs:
				self.Len = kwargs["Len"]
			if  2 < len(args):
				self.DataPtr = args[2]
			if "DataPtr" in kwargs:
				self.DataPtr = kwargs["DataPtr"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.LatentPayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.LatentPayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Data(self):
		return go.Slice_byte(handle=_datago.datago_LatentPayload_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_LatentPayload_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Len(self):
		return _datago.datago_LatentPayload_Len_Get(self.handle)
	@Len.setter
	def Len(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_LatentPayload_Len_Set(self.handle, value.handle)
		else:
			_datago.datago_LatentPayload_Len_Set(self.handle, value)
	@property
	def DataPtr(self):
		return _datago.datago_LatentPayload_DataPtr_Get(self.handle)
	@DataPtr.setter
	def DataPtr(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_LatentPayload_DataPtr_Set(self.handle, value.handle)
		else:
			_datago.datago_LatentPayload_DataPtr_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def GetClient(sources, require_images, require_embeddings, tags, tags__ne, has_attributes, lacks_attributes, has_masks, lacks_masks, has_latents, lacks_latents, crop_and_resize, default_image_size, downsampling_ratio, pre_encode_images, rank, world_size, prefetch_buffer_size, samples_buffer_size, downloads_concurrency):
	"""GetClient(str sources, bool require_images, bool require_embeddings, str tags, str tags__ne, str has_attributes, str lacks_attributes, str has_masks, str lacks_masks, str has_latents, str lacks_latents, bool crop_and_resize, int default_image_size, int downsampling_ratio, bool pre_encode_images, long rank, long world_size, int prefetch_buffer_size, int samples_buffer_size, int downloads_concurrency) object
	
	Create a new Dataroom Client
	"""
	return DataroomClient(handle=_datago.datago_GetClient(sources, require_images, require_embeddings, tags, tags__ne, has_attributes, lacks_attributes, has_masks, lacks_masks, has_latents, lacks_latents, crop_and_resize, default_image_size, downsampling_ratio, pre_encode_images, rank, world_size, prefetch_buffer_size, samples_buffer_size, downloads_concurrency))


# ---- Functions ---


