"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
from pydantic import model_serializer
from typing import Optional, TypedDict
from typing_extensions import NotRequired


class DocumentDocumentType(str, Enum):
    r"""Describes the contents of a document and how it is used"""
    ACCOUNT_DOCUMENT_TYPE_UNSPECIFIED = "ACCOUNT_DOCUMENT_TYPE_UNSPECIFIED"
    CERTIFICATE_OF_APPOINTMENT = "CERTIFICATE_OF_APPOINTMENT"
    FDIC_SWEEP_PROGRAM_AGREEMENT = "FDIC_SWEEP_PROGRAM_AGREEMENT"
    FPSL_MASTER_SERVICES_LOAN_AGREEMENT = "FPSL_MASTER_SERVICES_LOAN_AGREEMENT"
    TRANSFER_ON_DEATH_BENEFICIARY_DESIGNATION = (
        "TRANSFER_ON_DEATH_BENEFICIARY_DESIGNATION"
    )
    CHANGE_OF_ADDRESS = "CHANGE_OF_ADDRESS"
    NEW_ACCOUNT_FORM = "NEW_ACCOUNT_FORM"
    LETTER_3210 = "LETTER_3210"
    IRA_APPL_FORM = "IRA_APPL_FORM"
    RIA_IRA_APPL_FORM = "RIA_IRA_APPL_FORM"
    IRA_DEPOSIT_FORM = "IRA_DEPOSIT_FORM"
    RIA_IRA_DEPOSIT_FORM = "RIA_IRA_DEPOSIT_FORM"
    IRA_DIST_FORM = "IRA_DIST_FORM"
    RIA_IRA_DIST_FORM = "RIA_IRA_DIST_FORM"
    ROTH_APPL_FORM = "ROTH_APPL_FORM"
    RIA_ROTH_APPL_FORM = "RIA_ROTH_APPL_FORM"
    ROTH_DIST_FORM = "ROTH_DIST_FORM"
    RIA_ROTH_DIST_FORM = "RIA_ROTH_DIST_FORM"
    SIMPLE_CONT_TRANSM = "SIMPLE_CONT_TRANSM"
    ESA_APPL_FORM = "ESA_APPL_FORM"
    ESA_WTHDR_STATEMENT = "ESA_WTHDR_STATEMENT"
    DIR_CONV_FORM = "DIR_CONV_FORM"
    MRGN_OPTA_AGREEMENT = "MRGN_OPTA_AGREEMENT"
    IRA_BENE_FORM = "IRA_BENE_FORM"
    IRA_JRNL_FORM = "IRA_JRNL_FORM"
    SEP_EMPL_PLAN_DOC = "SEP_EMPL_PLAN_DOC"
    SIMPLE_ADOPT_AGREEMENT = "SIMPLE_ADOPT_AGREEMENT"
    SIMPLE_APPL_FORM = "SIMPLE_APPL_FORM"
    DEATH_CERTIFICATION = "DEATH_CERTIFICATION"


class UploadedDateTypedDict(TypedDict):
    r"""Date that the document was uploaded"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class UploadedDate(BaseModel):
    r"""Date that the document was uploaded"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class AccountDocumentTypedDict(TypedDict):
    r"""Fields specific to an account document"""

    account_id: NotRequired[str]
    r"""Identifies the account relevant to the document"""
    document_type: NotRequired[DocumentDocumentType]
    r"""Describes the contents of a document and how it is used"""
    uploaded_date: NotRequired[Nullable[UploadedDateTypedDict]]
    r"""Date that the document was uploaded"""


class AccountDocument(BaseModel):
    r"""Fields specific to an account document"""

    account_id: Optional[str] = None
    r"""Identifies the account relevant to the document"""
    document_type: Optional[DocumentDocumentType] = None
    r"""Describes the contents of a document and how it is used"""
    uploaded_date: OptionalNullable[UploadedDate] = UNSET
    r"""Date that the document was uploaded"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["account_id", "document_type", "uploaded_date"]
        nullable_fields = ["uploaded_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentIDDocumentDocumentType(str, Enum):
    r"""Describes the contents of a document and how it is used"""
    ID_DOCUMENT_TYPE_UNSPECIFIED = "ID_DOCUMENT_TYPE_UNSPECIFIED"
    BIRTH_CERTIFICATE = "BIRTH_CERTIFICATE"
    CUSTOMER_IDENTIFICATION_PROCESS = "CUSTOMER_IDENTIFICATION_PROCESS"
    DEATH_CERTIFICATE = "DEATH_CERTIFICATE"
    DRIVING_LICENSE = "DRIVING_LICENSE"
    EMPLOYER_CONSENT_FORM_407_LETTER = "EMPLOYER_CONSENT_FORM_407_LETTER"
    MARRIAGE_CERTIFICATE = "MARRIAGE_CERTIFICATE"
    PASSPORT = "PASSPORT"
    PROOF_OF_TAX_ID = "PROOF_OF_TAX_ID"
    SOCIAL_SECURITY_DOCUMENT = "SOCIAL_SECURITY_DOCUMENT"
    THIRD_PARTY_CIP_RESULTS = "THIRD_PARTY_CIP_RESULTS"
    STATE_ID_CARD = "STATE_ID_CARD"
    NATIONAL_ID_CARD = "NATIONAL_ID_CARD"
    PERMANENT_RESIDENT_VISA = "PERMANENT_RESIDENT_VISA"
    IRIS_ITIN_LETTER = "IRIS_ITIN_LETTER"
    UTILITY_BILL = "UTILITY_BILL"
    MILITARY_ID_CARD = "MILITARY_ID_CARD"
    MORTGAGE_STATEMENT = "MORTGAGE_STATEMENT"
    LEASE_AGREEMENT = "LEASE_AGREEMENT"
    EXECUTOR_CERTIFICATION = "EXECUTOR_CERTIFICATION"
    TRUSTEE_CERTIFICATION = "TRUSTEE_CERTIFICATION"


class DocumentUploadedDateTypedDict(TypedDict):
    r"""Date that the document was uploaded"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class DocumentUploadedDate(BaseModel):
    r"""Date that the document was uploaded"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class IDDocumentTypedDict(TypedDict):
    r"""Fields specific to an identity document"""

    document_type: NotRequired[DocumentIDDocumentDocumentType]
    r"""Describes the contents of a document and how it is used"""
    legal_natural_person_id: NotRequired[str]
    r"""Identifies the legal natural person relevant to the document"""
    uploaded_date: NotRequired[Nullable[DocumentUploadedDateTypedDict]]
    r"""Date that the document was uploaded"""


class IDDocument(BaseModel):
    r"""Fields specific to an identity document"""

    document_type: Optional[DocumentIDDocumentDocumentType] = None
    r"""Describes the contents of a document and how it is used"""
    legal_natural_person_id: Optional[str] = None
    r"""Identifies the legal natural person relevant to the document"""
    uploaded_date: OptionalNullable[DocumentUploadedDate] = UNSET
    r"""Date that the document was uploaded"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["document_type", "legal_natural_person_id", "uploaded_date"]
        nullable_fields = ["uploaded_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentInvestorDocumentDocumentType(str, Enum):
    r"""Describes the contents of a document and how it is used"""
    INVESTOR_DOCUMENT_TYPE_UNSPECIFIED = "INVESTOR_DOCUMENT_TYPE_UNSPECIFIED"
    CONFIRM_DAILY = "CONFIRM_DAILY"
    CONFIRM_MONTHLY = "CONFIRM_MONTHLY"
    FORM_CONSOLIDATED_1099 = "FORM_CONSOLIDATED_1099"
    FORM_1042_S = "FORM_1042_S"
    FORM_1099_Q = "FORM_1099_Q"
    FORM_1099_R = "FORM_1099_R"
    FORM_2439 = "FORM_2439"
    FORM_480_6_A = "FORM_480_6A"
    FORM_480_6_B = "FORM_480_6B"
    FORM_5498 = "FORM_5498"
    STATEMENT_MONTHLY = "STATEMENT_MONTHLY"
    STATEMENT_QUARTERLY = "STATEMENT_QUARTERLY"


class DocumentProcessDateTypedDict(TypedDict):
    r"""Date that the related activities were processed"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class DocumentProcessDate(BaseModel):
    r"""Date that the related activities were processed"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class InvestorDocumentTypedDict(TypedDict):
    r"""Fields specific to an investor document"""

    account_id: NotRequired[str]
    r"""Identifies the account relevant to the document"""
    document_type: NotRequired[DocumentInvestorDocumentDocumentType]
    r"""Describes the contents of a document and how it is used"""
    process_date: NotRequired[Nullable[DocumentProcessDateTypedDict]]
    r"""Date that the related activities were processed"""


class InvestorDocument(BaseModel):
    r"""Fields specific to an investor document"""

    account_id: Optional[str] = None
    r"""Identifies the account relevant to the document"""
    document_type: Optional[DocumentInvestorDocumentDocumentType] = None
    r"""Describes the contents of a document and how it is used"""
    process_date: OptionalNullable[DocumentProcessDate] = UNSET
    r"""Date that the related activities were processed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["account_id", "document_type", "process_date"]
        nullable_fields = ["process_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentTypedDict(TypedDict):
    r"""Describes a document that has been uploaded to Apex storage."""

    account_document: NotRequired[Nullable[AccountDocumentTypedDict]]
    r"""Fields specific to an account document"""
    correspondent_id: NotRequired[str]
    r"""Identifies the correspondent relevant to the document"""
    download_link: NotRequired[str]
    r"""Signed link used to download a document; The link expires one hour after being generated"""
    id_document: NotRequired[Nullable[IDDocumentTypedDict]]
    r"""Fields specific to an identity document"""
    investor_document: NotRequired[Nullable[InvestorDocumentTypedDict]]
    r"""Fields specific to an investor document"""
    name: NotRequired[str]
    r"""Identifier for the document"""


class Document(BaseModel):
    r"""Describes a document that has been uploaded to Apex storage."""

    account_document: OptionalNullable[AccountDocument] = UNSET
    r"""Fields specific to an account document"""
    correspondent_id: Optional[str] = None
    r"""Identifies the correspondent relevant to the document"""
    download_link: Optional[str] = None
    r"""Signed link used to download a document; The link expires one hour after being generated"""
    id_document: OptionalNullable[IDDocument] = UNSET
    r"""Fields specific to an identity document"""
    investor_document: OptionalNullable[InvestorDocument] = UNSET
    r"""Fields specific to an investor document"""
    name: Optional[str] = None
    r"""Identifier for the document"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "account_document",
            "correspondent_id",
            "download_link",
            "id_document",
            "investor_document",
            "name",
        ]
        nullable_fields = ["account_document", "id_document", "investor_document"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
