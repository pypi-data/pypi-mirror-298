from typing import List, Tuple
import requests
import urllib.parse
import json

from agricore_sp_models.import_models import SyntheticPopulationJsonDTO, FarmJsonDTO

class ABMInterface:
    """
    An interface for interacting with the ABM system's API for various operations related to population, farms, products, and policies.

    Attributes:
        baseUrl (str): The base URL for the API.
        currentPopulationId (Optional[int]): The ID of the current population.
        populationPath (str): Path for population-related API endpoints.
        populationAddPath (str): Path for adding a population.
        farmsAddPath (str): Path for adding farms.
        farmsPath (str): Path for farm-related API endpoints.
        dumpDataPath (str): Path for dumping data.
        filterDataPath (str): Path for filtering data.
        yearAddPath (str): Path for adding years.
        productGroupAddPath (str): Path for adding product groups.
        fadnProductsGetPath (str): Path for getting FADN products.
        fadnProductRelationAddPath (str): Path for adding FADN product relations.
        agriculturalProductionAddPath (str): Path for adding agricultural production.
        livestockProductionAddPath (str): Path for adding livestock production.
        closingValueAddPath (str): Path for adding closing values.
        policyAddPath (str): Path for adding policies.
        policyGetPath (str): Path for getting policies.
        policyProductGroupRelationAddPath (str): Path for adding policy-product group relations.
        holderFarmYearDataAddPath (str): Path for adding holder farm year data.
        farmYearSubsidiesAddPath (str): Path for adding farm year subsidies.
        syntheticPopulationAddPath (str): Path for adding synthetic populations.
        syntheticPopulationImportPath (str): Path for importing synthetic populations.
        debug (bool): Flag for enabling debug mode.
        fadnProducts (list): List of FADN products.
        farmsOrigToABMdict (dict): Mapping from original farm IDs to ABM farm IDs.
        farmsABMToOrigdict (dict): Mapping from ABM farm IDs to original farm IDs.
        productGroupsOrigToABMDict (dict): Mapping from original product group IDs to ABM product group IDs.
        productGroupsABMToOrigDict (dict): Mapping from ABM product group IDs to original product group IDs.
        productOrigToProductGroupOrig (dict): Mapping from original products to product groups.
    """

    baseUrl: str = ""
    currentPopulationId = None
    
    populationPath : str = "population/"
    populationAddPath : str= "population/add"
    farmsAddPath : str= "farms/add"
    farmsPath : str= "farms/"
    dumpDataPath : str= "dumpData"
    filterDataPath : str= "filterData"
    yearAddPath : str= "years/add"
    productGroupAddPath : str= "productGroup/add"
    fadnProductsGetPath : str= "FADNProducts/get"
    fadnProductRelationAddPath : str= "FADNProductRelation/add"
    agriculturalProductionAddPath : str= "agriculturalProduction/add"
    livestockProductionAddPath : str= "livestockProduction/add"
    closingValueAddPath : str= "closingValFarmValues/add"
    policyAddPath : str= "policies/add"
    policyGetPath: str = "policies/get"
    policyProductGroupRelationAddPath:str  = "policyProductGroupRelation/add"
    holderFarmYearDataAddPath:str  = "/HolderData/add"
    farmYearSubsidiesAddPath:str = "/farmYearSubsidy/add"
    syntheticPopulationAddPath:str = "/synthetic/add"
    syntheticPopulationImportPath:str = "synthetic/import"
    
    debug = False
    
    fadnProducts = []

    # Helper dicts to transform between values in the original data set and the ones generated by the ABM
    farmsOrigToABMdict = {}
    farmsABMToOrigdict = {}
    
    productGroupsOrigToABMDict = {}
    productGroupsABMToOrigDict = {}
    
    # Extra helper to save the groupings created by the SpecificDatasetConfiguration : ProductOrig -> CustomGroup
    productOrigToProductGroupOrig = {}

      
    def setBaseURL(self, url: str) -> None:
        """
        Sets the base URL for the API.

        Parameters:
            url (str): The base URL for the API.

        Returns:
            None
        """  
        self.baseUrl = url
        
    def cleanDicts(self) -> None:
        """
        Clears all internal dictionaries used for mapping and storing data.

        Returns:
            None
        """
        self.farmsOrigToABMDict = {}
        self.farmsABMToOrigDict = {}
        self.productGroupsOrigToABMDict = {}
        self.productGroupsABMToOrigDict = {}
        self.productOrigToProductGroupOrig = {}
        self.fadnProducts = []
        self.fadnCodeToIdDict = {}
        self.fadnIdToCodeDict = {}
        
    def loadFADNProducts(self) -> None:
        """
        Loads FADN products and populates internal mappings for product codes and IDs.

        Returns:
            None
        """
        self.fadnProducts = self.getFADNProducts()
        self.fadnCodeToIdDict = {}
        self.fadnIdToCodeDict = {}
        for product in self.fadnProducts:
            abmId = product["id"]
            fadnId = product["fadnIdentifier"]
            if self.debug:
                print("saving relation {0}-{1}".format(fadnId, abmId))
            self.fadnCodeToIdDict[fadnId]=abmId
            self.fadnIdToCodeDict[abmId]=fadnId
            
    def transformOrigFarmIdToAbm(self, origFarmId: str | int):
        """
        Transforms an original farm ID to an ABM farm ID.

        Parameters:
            origFarmId (str | int): The original farm ID.

        Returns:
            Optional[str]: The corresponding ABM farm ID or None if not found.
        """
        if type(origFarmId) is int:
            return self.farmsOrigToABMdict[str(origFarmId)]
        elif type(origFarmId) is str:
            return self.farmsOrigToABMdict[origFarmId]
        else:
            return None
    
    def transformABMFarmIdToOrig(self, farmId: str | int):
        """
        Transforms an ABM farm ID to an original farm ID.

        Parameters:
            farmId (str | int): The ABM farm ID.

        Returns:
            Optional[str]: The corresponding original farm ID or None if not found.
        """
        if type(farmId) is int:
            return self.farmsABMToOrigdict[str(farmId)]
        elif type(farmId) is str:
            return self.farmsABMToOrigdict[farmId]
        else:
            return None
        
    def transformABMProductGroupToOrig(self, productGroupId: str | int):
        """
        Transforms an ABM product group ID to an original product group ID.

        Parameters:
            productGroupId (str | int): The ABM product group ID.

        Returns:
            Optional[str]: The corresponding original product group ID or None if not found.
        """
        if type(productGroupId) is int:
            return self.productGroupsABMToOrig[str(productGroupId)]
        elif type(productGroupId) is str:
            return self.productGroupsABMToOrig[productGroupId]
        else:
            return None
        
    def transformOrigProductGroupToABM(self, productGroupId: str | int):
        """
        Transforms an original product group ID to an ABM product group ID.

        Parameters:
            productGroupId (str | int): The original product group ID.

        Returns:
            Optional[str]: The corresponding ABM product group ID or None if not found.
        """
        if type(productGroupId) is int:
            return self.productGroupsOrigToABMDict[str(productGroupId)]
        elif type(productGroupId) is str:
            return self.productGroupsOrigToABMDict[productGroupId]
        else:
            return None
    
    def transformFADNIdToCode(self, fadnProductId: str | int):
        """
        Transforms a FADN product ID to its corresponding code.

        Parameters:
            fadnProductId (str | int): The FADN product ID.

        Returns:
            Optional[str]: The corresponding product code or None if not found.
        """
        if type(fadnProductId) is int:
            return self.fadnIdToCodeDict[str(fadnProductId)]
        elif type(fadnProductId) is str:
            return self.fadnIdToCodeDict[fadnProductId]
        else:
            return None
        
    def transformFADNCodeIntoId(self, fadnProductId: str | int):
        """
        Transforms a FADN product code to its corresponding ID.

        Parameters:
            fadnProductId (str | int): The FADN product code.

        Returns:
            Optional[str]: The corresponding product ID or None if not found.
        """
        if type(fadnProductId) is int:
            return self.fadnCodeToIdDict[str(fadnProductId)]
        elif type(fadnProductId) is str:
            return self.fadnCodeToIdDict[fadnProductId]
        else:
            return None
    
    def populationAddURL(self) -> str:
        """
        Generates the URL for adding a population.

        Returns:
            str: The URL for adding a population.
        """
        return urllib.parse.urljoin(self.baseUrl, self.populationAddPath)

    def farmAddURL(self, populationId) -> str:
        """
        Generates the URL for adding a farm within a given population.

        Parameters:
            populationId (int): The ID of the population.

        Returns:
            str: The URL for adding a farm within the specified population.
        """
        return urllib.parse.urljoin(self.baseUrl, '{0}/{1}/{2}'.format(self.populationPath, str(populationId), self.farmsAddPath))

    def farmYearSubsidiesAddURL(self) -> str:
        """
        Generates the URL for adding farm year subsidies.

        Returns:
            str: The URL for adding farm year subsidies.
        """
        return urllib.parse.urljoin(self.baseUrl, self.farmYearSubsidiesAddPath)
    
    def dumpDataURL(self) -> str:
        """
        Generates the URL for dumping data.

        Returns:
            str: The URL for dumping data.
        """
        return urllib.parse.urljoin(self.baseUrl, self.dumpDataPath)
    
    def filterDataURL(self) -> str:
        """
        Generates the URL for filtering data.

        Returns:
            str: The URL for filtering data.
        """
        return urllib.parse.urljoin(self.baseUrl, self.filterDataPath)
    
    def yearAddURL(self, populationId) -> str:
        """
        Generates the URL for adding a year within a given population.

        Parameters:
            populationId (int): The ID of the population.

        Returns:
            str: The URL for adding a year within the specified population.
        """
        return urllib.parse.urljoin(self.baseUrl, '{0}/{1}/{2}'.format(self.populationPath, str(populationId), self.yearAddPath))
        
    def productGroupAddURL(self, populationId) -> str:
        """
        Generates the URL for adding a product group.

        Returns:
            str: The URL for adding a product group.
        """
        return urllib.parse.urljoin(self.baseUrl, '{0}/{1}/{2}'.format(self.populationPath, str(populationId), self.productGroupAddPath))
    
    def fadnProductGetURL(self) -> str:
        """
        Generates the URL for getting FADN products.

        Returns:
            str: The URL for getting FADN products.
        """
        return urllib.parse.urljoin(self.baseUrl, self.fadnProductsGetPath)
    
    def fadnProductRelationAddURL(self) -> str:
        """
        Generates the URL for adding FADN product relations.

        Returns:
            str: The URL for adding FADN product relations.
        """
        return urllib.parse.urljoin(self.baseUrl, self.fadnProductRelationAddPath)
    
    def agriculturalProductionAddURL(self) -> str:
        """
        Generates the URL for adding agricultural production data.

        Returns:
            str: The URL for adding agricultural production data.
        """
        return urllib.parse.urljoin(self.baseUrl, self.agriculturalProductionAddPath)
    
    def livestockProductionAddURL(self) -> str:
        """
        Generates the URL for adding livestock production data.

        Returns:
            str: The URL for adding livestock production data.
        """
        return urllib.parse.urljoin(self.baseUrl, self.livestockProductionAddPath)
    
    def closingValueAddURL(self) -> str:
        """
        Generates the URL for adding closing values.

        Returns:
            str: The URL for adding closing values.
        """
        return urllib.parse.urljoin(self.baseUrl, self.closingValueAddPath)
    
    def policyAddURL(self) -> str:
        """
        Generates the URL for adding a policy.

        Returns:
            str: The URL for adding a policy.
        """
        return urllib.parse.urljoin(self.baseUrl, self.policyAddPath)

    def policyGetURL(self, policyIdentifier) -> str:
        
        """
        Generates the URL for getting policies.

        Returns:
            str: The URL for getting policies.
        """
        return urllib.parse.urljoin(self.baseUrl, "{0}/{1}".format(self.policyGetPath, policyIdentifier))

    def policyProductGroupRelationAddURL(self, populationId) -> str:
        """
        Generates the URL for adding policy-product group relations.

        Returns:
            str: The URL for adding policy-product group relations.
        """
        return urllib.parse.urljoin(self.baseUrl, '{0}/{1}/{2}'.format(self.populationPath, str(populationId), self.policyProductGroupRelationAddPath))

    def holderFarmYearDataAddUrl(self, populationId, farmCode) -> str:
        """
        Generates the URL for adding holder farm year data.

        Returns:
            str: The URL for adding holder farm year data.
        """
        return urllib.parse.urljoin(self.baseUrl, '{0}/{1}/{2}/{3}/{4}'.format(self.populationPath, 
                                                                               str(populationId),
                                                                               self.farmsPath,
                                                                               farmCode,
                                                                               self.holderFarmYearDataAddPath))
    
    def syntheticPopulationAddURL(self) -> str:
        """
        Generates the URL for adding synthetic populations.

        Returns:
            str: The URL for adding synthetic populations.
        """
        return urllib.parse.urljoin(self.baseUrl, self.syntheticPopulationAddPath)
    
    def importSyntheticPopulationURL(self) -> str:
        """
        Generates the URL for importing synthetic populations.

        Returns:
            str: The URL for importing synthetic populations.
        """
        return urllib.parse.urljoin(self.baseUrl, self.syntheticPopulationImportPath)
    
    def addPartialDataURL(self, populationId: int) -> str:
        """
        Generates the URL for adding partial data to a specific population.

        Parameters:
            populationId (int): The ID of the population to which partial data will be added.

        Returns:
            str: The URL for adding partial data.
        """
        return urllib.parse.urljoin(self.baseUrl, f'population/{populationId}/addPartialData')
        
    def createPopulation(self, population):        
        """
        Creates a new population and returns its ID.

        Parameters:
            population (Population): The population data to be created.

        Returns:
            Optional[int]: The ID of the newly created population, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.populationAddURL(), json.dumps(population.dict(exclude={'id'})), headers=headers)
        if response.status_code == 201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            population.id = id
            self.currentPopulationId = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None

    def createSyntheticPopulation(self, synthetic):        
        """
        Creates a new synthetic population and returns its ID.

        Parameters:
            synthetic (SyntheticPopulation): The synthetic population data to be created.

        Returns:
            Optional[int]: The ID of the newly created synthetic population, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.syntheticPopulationAddURL(), json.dumps(synthetic.dict(exclude={'id'})), headers=headers)
        if response.status_code == 201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            synthetic.id = id
            self.currentSyntheticPopulationId = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
    
    # Returns the ID of the created farm or None
    def createFarm(self, farm):
        """
        Creates a new farm and returns its ID.

        Parameters:
            farm (Farm): The farm data to be created.

        Returns:
            Optional[int]: The ID of the newly created farm, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.farmAddURL(farm.dict().get('populationId')), json.dumps(farm.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id= response.json()["id"]
            farm.id = id
            self.farmsOrigToABMdict[farm.farmCode]=id
            self.farmsABMToOrigdict[id]=farm.farmCode
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
    
    def createProductGroup(self, productGroup):
        """
        Creates a new product group and returns its ID.

        Parameters:
            productGroup (ProductGroup): The product group data to be created.

        Returns:
            Optional[int]: The ID of the newly created product group, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.productGroupAddURL(productGroup.populationId), json.dumps(productGroup.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            self.productGroupsOrigToABMDict[productGroup.name]=id
            self.productGroupsABMToOrigDict[id]=productGroup.name
            originalProductList = productGroup.productsIncludedInOriginalDataset.strip().split(';')
            for product in originalProductList:
                self.productOrigToProductGroupOrig[(product, productGroup.organic)] = productGroup.name
            productGroup.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def createFADNProductRelation(self, fadnProductRelation):
        """
        Creates a new FADN product relation and returns its ID.

        Parameters:
            fadnProductRelation (FADNProductRelation): The FADN product relation data to be created.

        Returns:
            Optional[int]: The ID of the newly created FADN product relation, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        #print(message)
        response = requests.post(self.fadnProductRelationAddURL(), json.dumps(fadnProductRelation.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            fadnProductRelation.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def createAgriculturalProduction(self, agriculturalProduction):
        """
        Creates a new agricultural production record and returns its ID.

        Parameters:
            agriculturalProduction (AgriculturalProduction): The agricultural production data to be created.

        Returns:
            Optional[int]: The ID of the newly created agricultural production record, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        #print(message)
        response = requests.post(self.agriculturalProductionAddURL(), json.dumps(agriculturalProduction.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            agriculturalProduction.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def createLivestockProduction(self, livestockProduction):
        """
        Creates a new livestock production record and returns its ID.

        Parameters:
            livestockProduction (LivestockProduction): The livestock production data to be created.

        Returns:
            Optional[int]: The ID of the newly created livestock production record, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        #print(message)
        response = requests.post(self.livestockProductionAddURL(), json.dumps(livestockProduction.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            livestockProduction.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None

    def createFarmYearSubsidy(self, subsidy):
        """
        Creates a new farm year subsidy record and returns its ID.

        Parameters:
            subsidy (FarmYearSubsidy): The farm year subsidy data to be created.

        Returns:
            Optional[int]: The ID of the newly created farm year subsidy record, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        #print(message)
        response = requests.post(self.farmYearSubsidiesAddURL(), json.dumps(subsidy.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            subsidy.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None

        
    def createPolicy(self, policy):
        """
        Creates a new policy and returns its ID.

        Parameters:
            policy (Policy): The policy data to be created.

        Returns:
            Optional[int]: The ID of the newly created policy, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.policyAddURL(), json.dumps(policy.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            policy.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None

    def getPolicy(self, policy):
        """
        Retrieves a policy by its identifier and returns its ID.

        Parameters:
            policy (Policy): The policy object with the identifier to search for.

        Returns:
            Optional[int]: The ID of the policy if found, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.get(self.policyGetURL(policy.policyIdentifier), headers=headers)
        if response.status_code == 200:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            policy.id = id
            return id
        else:
            if self.debug:
                print("Request Error")
                print("{0}-{1}-{2}".format(response.status_code, response.content, response.url))
            return None
        
    def createPolicyProductGroupRelation (self, policyProductGroupRelation):
        """
        Creates a new policy-product group relation and returns its ID.

        Parameters:
            policyProductGroupRelation (PolicyProductGroupRelation): The policy-product group relation data to be created.

        Returns:
            Optional[int]: The ID of the newly created policy-product group relation, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.policyProductGroupRelationAddURL(policyProductGroupRelation.dict().get('populationId')), json.dumps(policyProductGroupRelation.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            policyProductGroupRelation.id = id
            return id 
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def createYear(self, year: int, population: int):
        """
        Creates a new year record for a specific population and returns its ID.

        Parameters:
            year (int): The year to be created.
            population (int): The ID of the population associated with this year.

        Returns:
            Optional[int]: The ID of the newly created year, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.yearAddURL(population), json.dumps({"yearNumber": year}), headers=headers)
        if response.status_code ==201:
            id = response.json()["id"]
            if self.debug:
                print("Request successful")
            return id
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def createClosingValue(self, closingvalue):
        """
        Creates a new closing value record and returns its ID.

        Parameters:
            closingvalue (ClosingValue): The closing value data to be created.

        Returns:
            Optional[int]: The ID of the newly created closing value record, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.closingValueAddURL(), json.dumps(closingvalue.dict(exclude={'id'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            closingvalue.id = id
            return id 
        else:
            if self.debug:
                print ("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def dumpAll(self):
        """
        Clears all data from the database.

        Returns:
            bool: True if the database was successfully cleared, otherwise False.
        """
        headers = {'Accept': '*/*'}
        response = requests.delete(self.dumpDataURL(), headers=headers)
        if response.status_code ==200:
            if self.debug:
                print("The database was cleaned")
            return True 
        else:
            if self.debug:
                print ("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return False
        
    def filterData(self):
        """
        Filters the data in the database.

        Returns:
            bool: True if the database was successfully filtered, otherwise False.
        """
        headers = {'Accept' : '*/*'}
        response = requests.put(self.filterDataURL(), headers=headers)
        if response.status_code==200:
            if self.debug:
                print("The database was filtered")
            return True
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return False
        
        
    def getFADNProducts(self):
        """
        Retrieves the list of FADN products.

        Returns:
            Optional[List[dict]]: The list of FADN products if the request is successful, or None if the request fails.
        """
        headers = {'Accept': 'text/plain'}
        response = requests.get(self.fadnProductGetURL(), headers=headers)
        if response.status_code ==200:
            if self.debug:
                print("Request successful")
            return json.loads(response.content)
        else:
            if self.debug:
                print ("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None

    def createHolderFarmYearData(self, farmCode, holderData):
        """
        Creates holder farm year data and returns its ID.

        Parameters:
            farmCode (str): The code of the farm associated with the holder data.
            holderData (HolderFarmYearData): The holder farm year data to be created.

        Returns:
            Optional[int]: The ID of the newly created holder farm year data, or None if the request fails.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.holderFarmYearDataAddUrl(self.currentPopulationId, farmCode),
                                 json.dumps(holderData.dict(exclude={'id', 'farmId'})), headers=headers)
        if response.status_code ==201:
            if self.debug:
                print("Request successful")
            id = response.json()["id"]
            holderData.id = id
            return id
        else:
            if self.debug:
                print("Request Error")
                print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return None
        
    def importSyntheticPopulation(self,  population: SyntheticPopulationJsonDTO) -> Tuple[int, int]:        
        """
        Imports a synthetic population and returns the IDs of the imported population and its associated population.

        Parameters:
            population (SyntheticPopulationJsonDTO): The synthetic population data to be imported.

        Returns:
            Tuple[int, int]: A tuple containing the ID of the newly imported synthetic population and its associated population ID.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.importSyntheticPopulationURL(), json.dumps(population.dict()), headers=headers)
            
        if response.status_code == 201:
            print("Request successful")
            id = response.json()["id"]
            populationId = response.json()["populationId"]
            return id, populationId
        else:
            print("Request Error")
            print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return 0,0
    
    def sendPartialFarmData(self,  population_id: int, farm_list: List[FarmJsonDTO]) -> bool:        
        """
        Sends partial farm data for a specific population.

        Parameters:
            population_id (int): The ID of the population to which the farm data will be sent.
            farm_list (List[FarmJsonDTO]): The list of farm data to be sent.

        Returns:
            bool: True if the request is successful, otherwise False.
        """
        headers = {'Accept': 'text/plain', 'Content-Type': 'application/json'}
        response = requests.post(self.addPartialDataURL(population_id), json.dumps([x.dict() for x in farm_list]), headers=headers)
        if response.status_code == 201:
            print("Request successful")
            return True
        else:
            print("Request Error")
            print ("{0}-{1}-{2}".format(response.status_code,response.content, response.url))
            return False

    @staticmethod
    def splitPopulationJsonDto(population: SyntheticPopulationJsonDTO, chunkSize: int) -> Tuple[SyntheticPopulationJsonDTO, List[FarmJsonDTO]]:
        """
        Splits a SyntheticPopulationJsonDTO into chunks of farm data.

        Parameters:
            population (SyntheticPopulationJsonDTO): The synthetic population data to be split.
            chunkSize (int): The size of each chunk of farm data.

        Returns:
            Tuple[SyntheticPopulationJsonDTO, List[List[FarmJsonDTO]]]: A tuple containing the modified population object and a list of farm data chunks.
        """
        chunks = []
        farm_list = population.population.farms
        population.population.farms = []
        for i in range(0, len(farm_list), chunkSize):
            if i == 0:
                population.farms = farm_list[i:i + chunkSize]
            else:
                chunk = farm_list[i:i + chunkSize]
            chunks.append(chunk)
        return population, chunks
