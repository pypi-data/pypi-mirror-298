from typing import Any, Optional
from urllib.parse import urlparse

from . import DPType, Responses


class Url(DPType):
    """
    A `Url` essentially is a `String` which has to match a url-format of
    `<scheme>://<netloc>/<path>;<params>?<query>#<fragment>`. The output
    is either a string or a named tuple (see `return_parsed`).

    Keyword arguments:
    schemes -- list of strings that are accepted as url-schemes
               (default `None` (accept any))
    require_netloc -- if `True`, only urls with non-empty netloc are
                      accepted
                      (default `False`)
    return_parsed -- if `True`, returns a named tuple as generated by
                     `urllib.parse.urlparse` instead of string
                     (default `False`)
    """
    TYPE = str

    def __init__(
        self,
        schemes: Optional[list[str]] = None,
        require_netloc: bool = False,
        return_parsed: bool = False
    ):
        self._schemes = schemes
        self._require_netloc = require_netloc
        self._return_parsed = return_parsed

    def make(self, json, loc: str) -> tuple[Any, str, int]:
        url = urlparse(json)
        if self._schemes is not None and url.scheme not in self._schemes:
            return (
                None,
                Responses().BAD_VALUE.msg.format(
                    origin=json,
                    loc=loc,
                    expected="scheme to be "
                    + ("one of " if len(self._schemes) > 1 else "")
                    + ", ".join(f"'{v}'" for v in self._schemes)
                ),
                Responses().BAD_VALUE.status
            )
        if self._require_netloc and url.netloc == "":
            return (
                None,
                Responses().BAD_VALUE.msg.format(
                    origin=json,
                    loc=loc,
                    expected="non-empty netloc"
                ),
                Responses().BAD_VALUE.status
            )
        return (
            url if self._return_parsed else json,
            Responses().GOOD.msg,
            Responses().GOOD.status
        )
