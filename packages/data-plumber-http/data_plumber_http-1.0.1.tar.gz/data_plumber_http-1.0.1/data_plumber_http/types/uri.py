from typing import Any, Optional
from urllib.parse import urlparse

from . import DPType, Responses


class Uri(DPType):
    """
    A `Uri` essentially is a `String` which has to match a uri-format of
    `<scheme>://<authority>/<path>?<query>#<fragment>`. The output
    is either a string or a named tuple (see `return_parsed`).

    Keyword arguments:
    schemes -- list of strings that are accepted as uri-schemes
               (default `None` (accept any))
    require_authority -- if `True`, only uris with non-empty authority
                      are accepted
                      (default `False`)
    return_parsed -- if `True`, returns a named tuple as generated by
                     `urllib.parse.urlparse` instead of string
                     (default `False`)
    """
    TYPE = str

    def __init__(
        self,
        schemes: Optional[list[str]] = None,
        require_authority: bool = False,
        return_parsed: bool = False
    ):
        self._schemes = schemes
        self._require_authority = require_authority
        self._return_parsed = return_parsed

    def make(self, json, loc: str) -> tuple[Any, str, int]:
        uri = urlparse(json)
        if self._schemes is not None and uri.scheme not in self._schemes:
            return (
                None,
                Responses().BAD_VALUE.msg.format(
                    origin=json,
                    loc=loc,
                    expected="scheme to be "
                    + ("one of " if len(self._schemes) > 1 else "")
                    + ", ".join(f"'{v}'" for v in self._schemes)
                ),
                Responses().BAD_VALUE.status
            )
        if self._require_authority and uri.netloc == "":
            return (
                None,
                Responses().BAD_VALUE.msg.format(
                    origin=json,
                    loc=loc,
                    expected="non-empty authority"
                ),
                Responses().BAD_VALUE.status
            )
        return (
            uri if self._return_parsed else json,
            Responses().GOOD.msg,
            Responses().GOOD.status
        )
